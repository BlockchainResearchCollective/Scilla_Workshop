(*********************************************)
(*      05. Folds and standard library       *)
(*********************************************)
(*  Uncomment specific code regions to try.  *)
(*********************************************)
(*            How to run it:                 *)
(* $SCILLA_HOME/bin/type-checker file.scilla *)
(* $SCILLA_HOME/bin/eval-runner  file.scilla *)
(*********************************************)


(*********************************)
(*      folding over naturals    *)
(*********************************)

(* forall 'T. ('T -> Nat -> 'T) -> 'T -> Nat -> 'T *)
(* let fold = nat_fold in fold *)

(*******************************************************)
(* Implementing addition on natural numbers via a fold *)
(*******************************************************)

(* let add_nat = *)
(*   fun (n : Nat) => fun (m : Nat) => *)
(*     let foldn = @nat_fold Nat in *)
(*     let folder = *)
(*       fun (acc : Nat) => fun (n : Nat) => Succ acc *)
(*     in foldn folder m n *)
(* in *)
(* let five = Uint32 5 in     *)
(* let six = Uint32 6 in *)
(* let five_nat = builtin to_nat five in *)
(* let six_nat = builtin to_nat six in *)
(* let res = add_nat five_nat six_nat in *)
(* res *)

(* Exercise 1: implement multiplication     *)
(* Exercise 2: implement factorial          *)
(* Exercise 3: implement exponentiation     *)
(* Exercise 4: implement Fibonacci numbers  *)
(* Exercise 5: implement Euclidean division *)


(*********************************)
(*      folding over lists       *)
(*********************************)

(* let fold = list_foldl in fold *)
(* let fold = list_foldr in fold *)

(* let list_map = tfun 'A => tfun 'B => *)
(*   fun (f : 'A -> 'B) => fun (l : List 'A) => *)
(*   let folder = @list_foldr 'A (List 'B) in *)
(*   let init = Nil {'B} in *)
(*   let iter = fun (h : 'A) => fun (z : List 'B) => *)
(*     let h1 = f h in *)
(*     Cons {'B} h1 z  		 *)
(* 	in folder iter init l *)
(* in *)
(* let map_int = @list_map Int32 Int32 in *)
(* let two = Int32 2 in *)
(* let double = fun (x : Int32) => builtin mul x two in *)
(* let double_all = map_int double *)
(* in double_all *)

(***************)
(* List length *)
(***************)

(* let list_length = *)
(*   tfun 'A => *)
(*   fun (l : List 'A) => *)
(*     let folder = @list_foldr 'A Uint32 in *)
(*     let init = Uint32 0 in *)
(*     let iter = *)
(*       fun (h : 'A) => *)
(*       fun (z : Uint32) => *)
(*         let one = Uint32 1 in *)
(*           builtin add one z *)
(*      in *)
(*        folder iter init l *)
(* in list_length *)

(**************************************)
(* Exercise 1: Implement list_append  *)
(* Exercise 2: Implement list_reverse *)
(**************************************)

(************************************************************)
(* Solutions and more examples are in the standard library! *)
(************************************************************)

