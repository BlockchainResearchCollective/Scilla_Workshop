(*********************************************)
(*      04. Functions and polymorphism       *)
(*********************************************)
(*  Uncomment specific code regions to try.  *)
(*********************************************)
(*            How to run it:                 *)
(* $SCILLA_HOME/bin/type-checker file.scilla *)
(* $SCILLA_HOME/bin/eval-runner  file.scilla *)
(*********************************************)

(********************************)
(* A simple function Int -> Int *)
(********************************)

(* let f_double = fun (x: Int32) => builtin add x x in *)
(* let y = Int32 42 in *)
(* f_double y y *)

(****************************)
(* An example with currying *)
(****************************)

(* let f_mul = *)
(*   fun (x: Int32) => *)
(*     fun (y : Int32) => builtin mul x y in *)
(* let z = Int32 42 in *)
(* let mul42 = f_mul z in *)
(* let a = Int32 3 in *)
(* mul42 a *)

(***************************)
(* Taking a head of a list *)
(***************************)

(* let lst_head = *)
(*   fun (l : List Int32) => *)
(*     match l with *)
(*     | Cons h t => *)
(*       Some {Int32} h *)
(*     | Nil => *)
(*       None {Int32} *)
(*     end *)
(* in *)
(* let n = Nil {Int32} in *)
(* let x = Int32 1 in *)
(* let l1 = Cons {Int32} x n in *)
(* lst_head l1 *)

(******************************)
(* Let's make it polymorphic! *)
(******************************)

(* let list_head = *)
(*   tfun 'A => *)
(*   fun (l : List 'A) => *)
(*     match l with *)
(*     | Cons h t => *)
(*       Some {'A} h *)
(*     | Nil => *)
(*       None {'A} *)
(*     end *)
(* in *)
(* let head_int32 = @list_head Int32 in *)
(* let n = Nil {Int32} in *)
(* let x = Int32 1 in *)
(* let l1 = Cons {Int32} x n in *)
(* head_int32 l1 *)

(********************************************)
(* Time to get some interesting stuff done. *)
(********************************************)

(********************)
(* Compose function *)
(********************)

(* let comp = *)
(*   tfun 'A => *)
(*     tfun 'B => *)
(*       tfun 'C => *)
(*       fun (f: 'A -> 'B) => *)
(*       fun (g : 'B -> 'C) => *)
(*       fun (x : 'A) => *)
(*         let r = f x in g r *)
(* in *)
(* let f = fun (x : Int32) => builtin to_int64 x in         *)
(* let g = fun (o : Option Int64) => *)
(*   match o with *)
(*   | Some z => builtin to_int128 z *)
(*   | None => let z = Int128 0 in Some {Int128} z *)
(*   end *)
(* in *)
(* let comp128 = @comp Int32 (Option Int64) (Option Int128) in *)
(* let cc = comp128 f g in *)
(* let a = Int32 42 in *)
(* cc a  *)

(*********************************)
(* More of polymorphic functions *)
(*********************************)

(* let f = tfun 'A => fun (x : 'A) => x in *)
(* let g = tfun 'B => fun (x : 'B) => x in *)
(* let p = Pair {(forall 'C. 'C -> 'C) (forall 'A. 'A -> 'A)} f g in *)
(* let s = "abc" in *)
(* let g = match p with *)
(*         | Pair a b => b *)
(*         end *)
(* in *)
(* g *)
